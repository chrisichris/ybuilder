module ybuilder.core.build;

import java.lang.Thread;
import java.io.File;

import org.xml.sax: Attributes, Locator, SAXParseException;
import org.xml.sax.helpers.AttributesImpl;

import yeti.lang:Struct;

import org.apache.tools.ant.types: Path,AbstractFileSet, FileSet, DirSet;
import org.apache.tools.ant.helper: AntXMLContext, ProjectHelper2,
                                    ProjectHelper2$ElementHandler;
import org.apache.tools.ant.input.DefaultInputHandler;
import org.apache.tools.ant: BuildLogger, DemuxInputStream, NoBannerLogger, 
                             Project, RuntimeConfigurable, Target, Task, 
                             UnknownElement;


typedef xmlelement = Text string 
                     | Element {
                            name is string, 
                            attributes is map<string,string>, 
                            subelements is list<xmlelement>
                        };
                                
typedef filePatternType = list?<Include string 
                                | Exclude string 
                                | Patterns (() -> filePatternType) >;
                                
typedef pathPatternType = list?<Fileset hash<string, filePatternType>
                                | Dirset hash<string, filePatternType> 
                                | Location string 
                                | Path string 
                                | Patterns ( () -> pathPatternType) >;

typedef projectType = {
    antProject is ~Project, 
    executedTargets is hash<string,boolean>, 
    logger is string -> (),
    properties is hash<string,string>,
    var args is list<string>
};
                    
typedef targetType = {
    name is string, 
    isLivecycle is boolean,
    pos is number,
    depends is array<targetType>,
    livecycles is array<targetType>,
    var description is string,
    var preFn is projectType -> (), 
    var fn is projectType -> (), 
    var postFn is projectType -> ()
};

typedef pathType = {
    var fn is () -> string
};


    

class AntBuilderLocator extends Locator
    int getColumnNumber() 0,

    int getLineNumber() 0,

    String getPublicId() "",

    String getSystemId() "",
end;

cprop v = {
    var fn = do (): v done;
};
prop fn1 = {
    var fn = do (): fn1 () done;
};

(~) prop = prop.fn (); 

path parent child = 
    prop \( (parent~) ^ (child is string)); 

setProp prop fn1 = 
    prop.fn := do (): fn1 () done;
    
setPath path parent child = 
    (path is pathType).fn := do (): (parent.fn ()) ^ child done;

basedir = {var fn = do (): "./" done};

joinPath parent child  = {
    var fn () = 
       (cs = (child is pathType).fn ();
        c= if strStarts? cs (basedir~) then
            strRight cs (strLength (basedir~));
        else
            cs;
        fi;
        ((parent is pathType).fn ()) ^ c)
};
    
/*    
pathComponent p = 
    case p of
    Basedir(): basedirStr;
    Childdir{component} : component;
    esac;
*/



(||) parentPath component = (path parentPath component)~;

createProject () = 
    (antProject = new Project();
     logger = new NoBannerLogger();
     logger#setMessageOutputLevel(Project#MSG_INFO);
     logger#setOutputPrintStream(System#out);
     logger#setErrorPrintStream(System#err);
     antProject#addBuildListener(logger);
     antProject#init();
     antProject#getBaseDir();

     {
        antProject, 
        executedTargets = [:], 
        logger txt = println txt, 
        var args = [], 
        properties = [:]
     } is projectType);		

el name atts subelements = 
    Element {
        name,
        attributes = atts,
        subelements,	
    } is xmlelement;
            
tel name atts text = el name atts [Text text];			

targets is hash<string,targetType> = [:];

isLivecycleTarget? target = (target is targetType).isLivecycle;
isCommandTarget? target = strStarts? (target is targetType).name "-";
    

addTargetToLivecycle target livecycle = 
    (push target.livecycles livecycle;
     push livecycle.depends target);

var _targetCounter = 0;
    
target name opts fn1 is string -> 'a -> 'b -> targetType = 
   (if name in targets then 
        failWith "\(name) already defined as target - use Redefine true option to set it anyway" 
    fi;
    
    t = {
        name, 
        depends = array [],
        isLivecycle = 
            fold do v le: 
                    v or case le of 
                         Livecycle x:x; _:false 
                         esac 
                 done false opts,
                 
        livecycles = array [],
        pos = synchronized _targetCounter 
            \(_targetCounter := _targetCounter +1; _targetCounter),
        var description = "", 
        var preFn = \(), 
        var fn = fn1, 
        var postFn = \()
    } is targetType;
    
    for opts do opt: 
        case opt of
        Depends d : push t.depends d;
        Dependencies ds: for ds (push t.depends);
        Description d : t.description := d;
        DependencyOf target : push (target is targetType).depends t;
        InLivecycle lc: addTargetToLivecycle t lc;
        Livecycle x: (); //already set in target construciton
        esac 
    done;

    
    targets.[t.name] := t;
    t);

    
forTargetDependencies target cont resFn = (
    pu ta = (cont.[ta.name] := true; resFn ta);
    emp = filter ((not) . (in cont) . (.name));
    for target.livecycles do lc:
        for (emp (filter isLivecycleTarget? lc.depends)) pu;
    done;
    for (emp (filter isLivecycleTarget? target.depends)) pu;
    for (emp (filter ((not) . isLivecycleTarget?) target.depends)) pu;
    ());
    
targetToString t = (
    deps = array [];
    forTargetDependencies t [:] (push deps);
    "-----\n\(if isLivecycleTarget? t then "* " else "" fi)\(t.name)\n   description:\(t.description)\n   depends: \(strJoin ", " (map (.name) deps))");   

cmdTargets = 
    target "-targets" 
        [Description "Shows all the available targets in current project"] 
        \(for (sortBy (on (<)(.pos)) (list targets)) 
            (println . targetToString));
    
cmdLivecycles = 
    target "-livecycles" 
        [Description "Shows all livecycles in current project"] 
        \(for (sortBy (on (<)(.pos)) (filter isLivecycleTarget? (list targets))) 
            (println . targetToString));
            
cmdHelp = 
    target "-help" 
        [Description "Shows all the command targets"] 
        \(for (sortBy (on (<)(.pos)) (filter isCommandTarget? (list targets))) 
            (println . targetToString));

    
executeTarget target opts project is targetType -> 'a -> 'b -> 'c= 
   (var runAlways = false;
    var targetArgs = [];
    for opts do opt: 
                case opt of
                RunAlways v : runAlways := v;
                Exclude target: project.executedTargets.[target.name] := true;
                ExcludeByName name: project.executedTargets.[name] := true;
                Args args: targetArgs := args;
                Properties h: insertHash project.properties h;
                esac 
             done;
    if runAlways 
       or (not (target is targetType).name in project.executedTargets) then
        project.executedTargets.[target.name] := true;
        forTargetDependencies target [:] do t: executeTarget t[] project done;
        oldArgs = project.args;
        project.args := targetArgs;
        try
            println "Exectuing target \(target.name)";
            target.preFn project; target.fn project; target.postFn project;
        finally
            project.args := oldArgs;
        yrt
    fi);
        
        
runTarget target opts =
    executeTarget  target opts (createProject ());


antfact antElementHandler antXmlContext elem =
    case (elem is xmlelement) of
    Element {name, attributes, subelements}: 
       ({sname,ns} = 
           (inn = strTrim name;
            cut = strIndexOf inn " " 0;
            if cut == (-1) then {sname = inn, ns = ""}
            else
                {sname = strTrim (strRight inn cut),
                ns = strTrim (strLeft inn cut)}
            fi);
                        
        saxAtts = new AttributesImpl();
        forHash attributes do key value:
            saxAtts#addAttribute((), key, key, "CDATA", value) 
        done;

        (antElementHandler is ~ProjectHelper2$ElementHandler)
            #onStartElement(ns, sname, sname,
                            saxAtts, (antXmlContext is ~AntXMLContext));

        for subelements do ele: _ = 
                            antfact antElementHandler antXmlContext ele 
                        done;
        
        wrapper = (antXmlContext#getWrapperStack()#lastElement()) 
                unsafely_as ~RuntimeConfigurable;

        antElementHandler#onEndElement((),(),antXmlContext);
        wrapper#getProxy();
    );

    Text str : 
        (antElementHandler#characters(
                    ((str is string) unsafely_as ~String)#toCharArray(), 
                    0, strLength str, antXmlContext);
         () unsafely_as ~Object);
    esac;

_antProjectElementHandler = new ProjectHelper2$ElementHandler();

antTaskWithElement elem ybtProject = 
   (project is ~Project = ybtProject.antProject;
    collectorTarget = new Target();
    antXmlContext = new AntXMLContext(project is ~Project);
    collectorTarget#setProject(project);
    antXmlContext#setCurrentTarget(collectorTarget);
    antXmlContext#setLocator(new AntBuilderLocator());

    //execute
    node = antfact _antProjectElementHandler antXmlContext elem;
    if nullptr? node then
        ()
    elif node instanceof Task then
        task = if node instanceof UnknownElement then
                    ue = node unsafely_as ~UnknownElement;
                    ue#maybeConfigure();
                    ue#getRealThing();
               else
                    node 
               fi;
        if task instanceof Task then
            originalIn = System#in;
            projectDefaultStream = project#getDefaultInputStream();
            project#setDefaultInputStream(originalIn);
            System#setIn(new DemuxInputStream(project));

            (task unsafely_as ~Task)#perform();
            System#setIn(originalIn);
            project#setDefaultInputStream(projectDefaultStream);
        fi
    else
        (node unsafely_as ~RuntimeConfigurable)#maybeConfigure(project);
    fi;
    node);

antTask name atts subelements project = 
    (_ = antTaskWithElement (el name atts subelements) project;
     ());

antPatterns patts = 
    concatMap do pat: 
            case pat of
            Include name: [el "include" ["name":name][]];
            Exclude name: [el "exclude" ["name":name][]];
            Patterns pa: antPatterns (pa ());
            esac 
        done patts; 

antFileset dir patts =  
    el "fileset" ["dir" : dir] (antPatterns patts);
antDirset dir patts =  
    el "dirset" ["dir" : dir] (antPatterns patts);

antPathElements patts = 
   (filesets = array [];
    dirsets = array [];
    root = array[];
    withPatts pattsI =
        for (pattsI is pathPatternType) do pat:
                case pat of
                Fileset h: 
                    forHash h do k v: 
                        push filesets (antFileset k v) 
                    done;
                Dirset h: 
                    forHash h do k v:
                        push dirsets (antDirset k v)
                    done;
                Path str : push root (el "pathelement" ["path" : str] []);
                Location str: push root (el "pathelement" ["location" : str] []);
                Patterns pa: withPatts ( pa ());
                esac; 
            done;
    withPatts patts;
    list (root ++ filesets ++ dirsets)); 
    

createAntPath patts	= 
   (name="foox";
    project = createProject();
    antTask "path" ["id" : name] (antPathElements patts) project;
    (project.antProject#getReference(name)) unsafely_as ~Path);
    
createAntFileSet dir patts	= 
   (name="foox";
    project = createProject();
    antTask "fileset" ["dir":dir, "id" : name] (antPatterns patts) project;
    ((project.antProject#getReference(name)) unsafely_as ~FileSet));

createAntDirSet dir patts	= 
   (name="foox";
    project = createProject();
    antTask "dirset" ["dir":dir, "id" : name] (antPatterns patts) project;
    ((project.antProject#getReference(name)) unsafely_as ~DirSet));
    
    
getAntPathFromProject name project = 
   (var ref = (project is projectType).antProject#getReference(name is string);
    if not defined? ref then 
        () unsafely_as ~Path;
    elif not ref instanceof Path then 
        failWith "Under name [\(name)] is no path-ref but a [\(ref)]";
    else 
        ref unsafely_as ~Path 
    fi;);
    
getAntAbstractFileSetFromProject name project = 
   (var ref = (project is projectType).antProject#getReference(name is string);
    if not defined? ref then 
        () unsafely_as ~AbstractFileSet;
    elif not ref instanceof AbstractFileSet then 
        failWith "Under name [\(name)] is no path-ref but a [\(ref)]";
    else 
        ref unsafely_as ~AbstractFileSet 
    fi);

    
file name = new File(name is string);
assert cond text = if not cond then failWith text else () fi;

ybuilderVersion = "0.1-alpha";
cmdYbuilderVersion = 
    target "-ybuilderVersion" 
        [Description "The verstion of ybuilder: \(ybuilderVersion)"] 
        (antTask "echo" ["message":"ybuilder version \(ybuilderVersion)"] []); 

{
    prop,
    cprop,
    setProp,
    path, 
    setPath,
    joinPath,
    (~), 
    (||), 
    //(|) p c = path p c,
    assert,
    ybuilderVersion,
    cmdYbuilderVersion,
    basedir,

    createAntPath, createAntFileSet, createAntDirSet, getAntPathFromProject, getAntAbstractFileSetFromProject,
    targetToString,

    cmdTargets,
    cmdLivecycles,
    cmdHelp,
    targets,
    target,
    addTargetToLivecycle,
    runTarget,
    executeTarget,
    createProject,
    el,
    tel,
    antTaskWithElement,
    antTask,
    antPatterns,
    antFileset,
    antDirset,
    antPathElements,
    file,
}


