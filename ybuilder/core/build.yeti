/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module ybuilder.core.build;

import java.lang:System,Thread, ClassLoader;
import java.io.File;

import org.xml.sax: Attributes, Locator, SAXParseException;
 
import org.xml.sax.helpers.AttributesImpl;

import yeti.lang:Struct;

import org.apache.tools.ant.types: Path,AbstractFileSet, FileSet, DirSet;
import org.apache.tools.ant.helper: AntXMLContext, ProjectHelper2,
                                    ProjectHelper2$ElementHandler;
import org.apache.tools.ant.input.DefaultInputHandler;
import org.apache.tools.ant: BuildLogger, DemuxInputStream, NoBannerLogger, 
                             Project, RuntimeConfigurable, Target, Task, 
                             UnknownElement,AntClassLoader;


typedef xmlelement = Text string 
                     | Element {
                            name is string, 
                            attributes is map<string,string>, 
                            subelements is list<xmlelement>
                        };
                                

typedef projectType = {
    antProject is ~Project, 
    executedTargets is hash<string,boolean>, 
    logger is string -> (),
    properties is hash<string,string>,
    var args is list<string>
};
                    
typedef targetType = {
    name is string, 
    depends is array<targetType>,
    var preDependenciesFn is projectType -> (),
    var description is string,
    var fn is projectType -> (), 
};


typedef filePatternType = list<Include string
                                | Exclude string 
                                | Patterns ( () -> filePatternType) >;
                                
typedef pathPatternType = array<Fileset hash<string, filePatternType>
                                | Dirset hash<string, filePatternType> 
                                | Location string 
                                | Path string 
                                | PathPatterns ( () -> pathPatternType)>;
    

class AntBuilderLocator extends Locator
    int getColumnNumber() 0,

    int getLineNumber() 0,

    String getPublicId() "",

    String getSystemId() "",
end;

ybuilderVersion = "0.6";


createBuildConfig () = {
    basedir = "./",
    targets = [:] is hash<string,targetType>,
    targetsInHelp is array<targetType>= array [],
    var defaultTarget = none is Some targetType | None (), 
    
};

createProject () = 
    (antProject = new Project();
     logger = new NoBannerLogger();
     logger#setMessageOutputLevel(Project#MSG_INFO);
     logger#setOutputPrintStream(System#out);
     logger#setErrorPrintStream(System#err);
     antProject#addBuildListener(logger);
     antProject#init();
     antProject#getBaseDir();

     {
        antProject, 
        executedTargets = [:], 
        logger txt = println txt, 
        var args = [], 
        properties = [:]
     } is projectType);		

el name atts subelements = 
    Element {
        name,
        attributes = atts,
        subelements,	
    } is xmlelement;
            
tel name atts text = el name atts [Text text];			

    
target config group namep opts fn1 
    is 'c -> string -> string -> 'a -> 'b -> targetType = 
   (name = group ^ ":" ^ namep;
   if name in config.targets then 
        failWith "\(name) already defined as target" 
    fi;
    
    t = {
        name, 
        depends = array [],
        var description = "",
        var preDependenciesFn = \(),
        var fn = fn1, 
    } is targetType;
    
    for opts do opt: 
        case opt of
        Depends d : push t.depends d;
        Dependencies ds: for ds (push t.depends);
        Description d : t.description := d;
        DependencyOf target : push (target is targetType).depends t;
        Before target : push (target is targetType).depends t;
        DoPreDependencies fn : t.preDependenciesFn := fn;
        ShortName () : 
            if namep in config.targets then
                failWith "\(namep) already defined as target"
            else
                config.targets[namep] := t;
            fi;
        esac 
    done;
    
    config.targets[t.name] := t;
    t);

doAfterTarget target fn =
    (oFn = (target is targetType).fn;
     target.fn := do p: 
        oFn p;
        fn p;
     done);

targetToString t = (
    deps = list t.depends;
    "---\n\(t.name)"
    ^ "\n"
    ^ if (strLength t.description) > 0 then
        "   \(t.description)\n"
    else
        ""
    fi
    ^ "   depends: \(strJoin ", " (map (.name) deps))");   

printSimilarTargets targets name =
   (n = name;
    ts = filter do t: strStarts? t.name n done 
        (mapHash do k t: t done targets);
    if empty? ts then
        println "There are no targets starting with [\(n)]";
    else
        println "Targets starting with [\(n)]:\n";
        for ts do t:
            println 
                String#format("%1$-15s %2$s\n",
                            array [t.name,t.description])
        done;
    fi);
            
printTargets config =            
    (ts = array (list config.targets)
    |> groupBy do t t2:
        cut = strIndexOf t.name ":" 0;
        if cut < 0 then
            strIndexOf t2.name ":" 0 == cut;
        else
            prefix = strLeft t.name cut;
            strStarts? t2.name (prefix^":")
        fi
    done;
    println "all targets"; 
    for ts do ts2:
        println "next...";
        for ts2 (println . targetToString)
    done);
    
executeTarget target opts project is targetType -> 'a -> 'b -> 'c= 
   (var runAlways = false;
    var targetArgs = [];
    for opts do opt: 
                case opt of
                RunAlways v : runAlways := v;
                Exclude target: project.executedTargets[target.name] := true;
                ExcludeByName name: project.executedTargets[name] := true;
                Args args: targetArgs := args;
                Properties h: insertHash project.properties h;
                esac 
             done;
    if runAlways 
       or (not (target is targetType).name in project.executedTargets) then
        project.executedTargets[target.name] := true;


        oldArgs = project.args;
        project.args := targetArgs;

        target.preDependenciesFn project;
        
        for target.depends do t:
            executeTarget t [] project;
        done;
        if "verbose" in project.properties then
            println "--\(target.name)";
        fi;
        try
            //println "Exectuing target \(target.name)";
            target.fn project;
        finally
            project.args := oldArgs;
        yrt
    fi);

class YbuilderAntException(String message, Exception ca) extends RuntimeException(message,ca) 
end;
        
runTarget target opts =
    executeTarget  target opts (createProject ());

antfact antElementHandler antXmlContext elem =
    case (elem is xmlelement) of
    Element {name, attributes, subelements}: 
       ({sname,ns} = 
           (inn = strTrim name;
            cut = strIndexOf inn " " 0;
            if cut == (-1) then {sname = inn, ns = ""}
            else
                {sname = strTrim (strRight inn cut),
                ns = strTrim (strLeft inn cut)}
            fi);
                        
        saxAtts = new AttributesImpl();
        forHash attributes do key value:
            saxAtts#addAttribute((), key, key, "CDATA", value) 
        done;

        (antElementHandler is ~ProjectHelper2$ElementHandler)
            #onStartElement(ns, sname, sname,
                            saxAtts, (antXmlContext is ~AntXMLContext));

        for subelements do ele: _ = 
                            antfact antElementHandler antXmlContext ele 
                        done;
        
        wrapper = (antXmlContext#getWrapperStack()#lastElement()) 
                unsafely_as ~RuntimeConfigurable;

        antElementHandler#onEndElement((),(),antXmlContext);
        wrapper#getProxy();
    );

    Text str : 
        (antElementHandler#characters(
                    ((str is string) unsafely_as ~String)#toCharArray(), 
                    0, strLength str, antXmlContext);
         () unsafely_as ~Object);
    esac;

_antProjectElementHandler = new ProjectHelper2$ElementHandler();

antTaskWithElement elem ybtProject = 
    try 
        project = (ybtProject is projectType).antProject;
        collectorTarget = new Target();
        antXmlContext = new AntXMLContext(project is ~Project);
        collectorTarget#setProject(project);
        antXmlContext#setCurrentTarget(collectorTarget);
        antXmlContext#setLocator(new AntBuilderLocator());

        //execute
        node = antfact _antProjectElementHandler antXmlContext elem;
        if nullptr? node then
            ()
        elif node instanceof Task then
            task = if node instanceof UnknownElement then
                        ue = node unsafely_as ~UnknownElement;
                        ue#maybeConfigure();
                        ue#getRealThing();
                   else
                        node 
                   fi;
            if task instanceof Task then
                originalIn = System#in;
                projectDefaultStream = project#getDefaultInputStream();
                project#setDefaultInputStream(originalIn);
                System#setIn(new DemuxInputStream(project));

                    (task unsafely_as ~Task)#perform();
                
                System#setIn(originalIn);
                project#setDefaultInputStream(projectDefaultStream);
            fi
        else
            (node unsafely_as ~RuntimeConfigurable)#maybeConfigure(project);
        fi;
        node
    catch Exception ex: 
        throw new YbuilderAntException(ex#getMessage(),ex);
    yrt;
    

antTask name atts subelements project = 
    (_ = antTaskWithElement (el name atts subelements) project;
     ());

antInExcludeElements patts = 
    concatMap do pat: 
            case pat of
            Include name: [el "include" ["name":name][]];
            Exclude name: [el "exclude" ["name":name][]];
            Patterns pa: antInExcludeElements (pa ());
            esac 
        done patts;

antFilesetElement dir patts =  
    el "fileset" ["dir" : dir] (antInExcludeElements patts);

antDirsetElement dir patts =  
    el "dirset" ["dir" : dir] (antInExcludeElements patts);

antPathElements patts = 
   (filesets = array [];
    dirsets = array [];
    root = array[];
    withPatts pattsI =
        for pattsI  do pat:
                case pat of
                Fileset h: 
                    forHash h do k v: 
                        push filesets (antFilesetElement k v) 
                    done;
                Dirset h: 
                    forHash h do k v:
                        push dirsets (antDirsetElement k v)
                    done;
                Path str : push root (el "pathelement" ["path" : "${\(str)}"] []);
                Location str: push root (el "pathelement" ["location" : str] []);
                PathPatterns pa: withPatts (list ( pa ()));
                esac; 
            done;
    withPatts (list patts);
    (list (root ++ filesets ++ dirsets))); 
    

_createAntPath project patts	= 
   (name="foox";
    antTask "path" ["id" : name] (antPathElements patts) project;
    (project.antProject#getReference(name)) unsafely_as ~Path);

createAntPath patts = _createAntPath (createProject ()) patts;

listPath patts = 
    (createAntPath patts)#list() as list<string>;   

createAntClassLoader patts opts =
   (var parentClassLoader = ClassLoader#getSystemClassLoader()#getParent();
    var parentFirst = true;
    for opts do opt:
        case opt of
        ParentFirst bo : parentFirst := bo;
        Parent cl : parentClassLoader := cl;
        esac
    done;
    proj = createProject ();
    path = _createAntPath proj patts;
    new AntClassLoader(parentClassLoader, proj.antProject,path,parentFirst));
    
    
listFiles dir patts	= 
   (name="foox";
    project = createProject();
    antTask "fileset" ["dir":dir, "id" : name] (antInExcludeElements patts) 
        project;
    r = ((project.antProject#getReference(name)) unsafely_as ~FileSet)
        #getDirectoryScanner()#getIncludedFiles();
    map (strReplace File#separator "/") r);

listDirs dir patts	= 
   (name="foox";
    project = createProject();
    antTask "dirset" ["dir":dir, "id" : name] (antInExcludeElements patts)
        project;
    r = ((project.antProject#getReference(name)) unsafely_as ~DirSet)
        #getDirectoryScanner()#getIncludedDirectories();
    map (strReplace File#separator "/") r);
    
    

    
file name = 
    new File(name is string);

assert text cond = if not cond then failWith text else () fi;

millisSinceStart () =
    (pr = System#getProperty("ybuilder.starttime");
    if defined? pr then
        System#currentTimeMillis() - (number pr);
    else
        -1000
    fi);


readProperties propsFile =        
   (import java.util:Properties,
                    LinkedHashSet,
                    Enumeration,
                    Collections,
                    Set;
    import java.io.FileReader;

    if not (propsFile is ~File)#exists() then
        {names = [], values = [:]};
    else
        class LinkedProperties extends Properties
            keysSet = new LinkedHashSet(),
            
            Enumeration keys()
                Collections#enumeration(keysSet),
                
            Object put(Object key, Object value)
                _ = keysSet#add(key);
                super#put(key,value),
                
            Set stringPropertyNames() 
                keysSet
        end;
        props = new LinkedProperties();
        r = new FileReader(propsFile);
        try
            props#load(r);
        finally
            r#close();
        yrt;
        nas = array [];
        vas = [:];
        enum = props#keys();
        (enum#hasMoreElements()) loop (
            k = string enum#nextElement();
            v = string props#get(k);
            push nas k;
            vas[k] := v);
        {names = list nas,
         values = vas};
    fi);

buildDependenciesConfig = {
    ybuilder = "lib/ybuilder/",
    ybuilderLibsManaged = "lib/ybuilder/extlib_managed/",
    ybuilderProjectClasses = "lib/ybuilder/project"
};

retrieveBuildDependencies () =
   (import java.util.regex: Pattern;
    //content = readFile "project.yeti" "utf-8" getContents;
    {deps, reps} = if (file "project.yeti")#exists() then
        inLines = readFile "project.yeti" "utf-8" getLines;
        content = strJoin "" 
            ((map ((flip strRight) 2) . filter ((flip strStarts?) "//"))
             inLines) ;

        deps = 
            array 
                (catSome (matchAll '\s*@buildDependency\s([^;]*);' 
                do smatch:
                s = smatch[1];
                a = (like '\s*"([^"]+)"\s*"([^"]+)"\s*"([^"]+)"(.*)' s) ();//"
                if empty? a then 
                    failWith "Error in @buildDependency: Arguments wrong: \(s)";
                else
                    rs = strTrim (a[4]);
                    if strLength rs == 0 then
                        Some {dep = a, exc = []};
                    else
                        a2 = (like '\[(.*)\]' rs) ();
                        if empty? a2 then
                            Some {dep = a, exc = []};
                        else
                            exs = a2[1];
                            exc = matchAll 
                                '\s*exclusion\s*"([^"]*)"\s*"([^"]*)"\s*,?\s*' 
                                    do s: 
                                        pair s[1] s[2] 
                                    done
                                do ws:
                                    failWith ("Error in @buildDependency: "
                                    ^"Exclusion Arguments wrong: \(s):[\(ws)]")
                                done
                                exs;
                            Some {dep = a, exc};
                        fi
                    fi;            
                fi;
            done
            \none
            content));
            
        reps = array (catSome (matchAll '\s*@buildRepository\s([^;]*);' 
            do smatch:
                s = smatch[1];
                a = (like '\s*"([^"]+)"\s*"([^"]+)"\s*$' s) (); 
                if empty? a then 
                    failWith "Error in @buildRepository: Arguments wrong: \(s)";
                else
                    Some a
                fi;
            done
            \none
            content));
        {deps, reps}
    else
        {deps = array [], reps = array []}
    fi;

    //push to deps also jgit and stringtemplate
    //push reps ["jgit-repository", "http://download.eclipse.org/jgit/maven"];
    
    
    //retrieve the libs
    (maven str = ("antlib:org.apache.maven.artifact.ant " ^ str);
    project = createProject();
    
    antTask "delete" 
            ["dir":buildDependenciesConfig.ybuilderLibsManaged] 
            [] project;
    antTask "mkdir" 
            ["dir":buildDependenciesConfig.ybuilderLibsManaged] 
            [] project;
    if not empty? deps then
        antTask (maven "dependencies") 
                ["filesetId" : "dependenciesFS", "useScope":"runtime"] 
                ([el (maven "localRepository") 
                     ["layout":"default", 
                      "path":"${user.home}/.m2/repository"] []] 
                 ++ (map do rr: 
                        el (maven "remoteRepository") 
                           ["id":rr[1], "url":rr[2],"layout":"default"] 
                           [] 
                     done reps) 
                 ++ (map do d: 
                        el (maven "dependency") 
                           ["groupId" : d.dep[1],
                            "artifactId" : d.dep[2],
                            "version" : d.dep[3],
                            "scope" : "runtime"]
                            (map do exc: 
                                 el (maven "exclusion") 
                                    ["groupId":exc.fst, 
                                     "artifactId":exc.snd] [] 
                                 done d.exc) 
                     done deps)) 
                project;
                    
        antTask "copy" ["todir":buildDependenciesConfig.ybuilderLibsManaged] 
                [el "fileset" ["refid":"dependenciesFS"][],
                 el "mapper" ["type":"flatten"] []] 
                project;
    fi;
    ));

registerBuildTargets config =
    (
    cmdYbuilderVersion = 
        target config "help" "version"
            [Description "The verstion of ybuilder: \(ybuilderVersion)",
            ShortName()] 
            (antTask "echo" 
                 ["message":("ybuilder version \(ybuilderVersion) "
                    ^"yeti-version: \(yetiRuntimeVersion)")] 
                 []);
    
    cmdTargets = 
        target config "help" "targets" 
            [Description "Shows all the available targets in current project",
            ShortName()] 
            do p:
                printTargets config;
            done;
        

    help = 
        target config "help" "help" 
            [Description "Shows help",
            ShortName()] 
            do p:
            if empty? p.args then
                println "\nybuilder version: \(ybuilderVersion) \n";
                println '
ybuilder is a simple build-enviroment for YETI the functional 
programming-language for the JVM.
----

To run ybuilder targets defined in project.yeti:

java -jar ybuilder.jar target [params] [-property] [, target [param] [-property] ]+

target       name of the target to run
params       space seperated list of params for target
property     space seperated list of -key=value pairs starting with - for target

-or-

To run yeti-expression in ybuilder enviroment:

java -jar ybuilder.jar #yeti-expression

---
targets:

-c              Starts ybuilder in repl mode

-yeti           Same as invoking the yeti.jar in your project but with the full 
                classpath setup  

help            Prints this message

retrieveBuildLibs downloads the build libs into ybuilder/libext_managed dir 

cleanBuildLibs  deletes the ybuilder/libext_managed directory 
                triggering fresh load next time
';
                
                printTargets config;
            else
                for p.args (printSimilarTargets config.targets);
            fi;
            done;
            
    buildlibsDelete = target config "buildlibs" "delete" 
            [Description 
            "deletes the buildlibs dir, which triggers next time a retrieve"]
        do p:
        antTask "delete" 
                    ["dir":buildDependenciesConfig.ybuilderLibsManaged] 
                    []
                    p;

        done;

    buildlibsRetrieve = target config "buildlibs" "retrieve" 
            [Description "retrieves the buildlibs"]
        do p:
            retrieveBuildDependencies ();
        done;

    push config.targetsInHelp cmdTargets;       

    {
        help,
        cmdYbuilderVersion,
        cmdTargets,
        buildlibsDelete,
        buildlibsRetrieve
    });



//run things
_repl eval = 
    (print "ybuilder> ";
    line = readln();
    if defined? line then
        ls = if strStarts? line "#" then 
                [line] 
             else 
                list (strSplit " " line) 
             fi;
        print (eval ls);
        _repl eval;
    else
        println ""
    fi);



_evalFun = (load yeti.lang.compiler.eval).evaluateYetiCode [] [Bind()];
_evaluate config argv = 
    if empty? argv then
        "\n";
    else
        if strStarts? (head argv) "#" then
            code = strRight (strJoin " " argv) 1;
            (_evalFun code).str;
        else
            nargs = 
                fold do als s:
                        addStr str =
                            (a = head als;
                            if strStarts? str "-"then
                                cut= strIndexOf str "=" 0;
                                if cut > 0 then
                                    value = strRight str (cut+1);
                                    key = strSlice str 1 cut;
                                    a.properties[key] := value;
                                else
                                    push a.params str
                                fi;
                            elif (strLength str) > 0 then
                                push a.params str
                            fi);
                        if strEnds? s "," then
                            sf = strLeft s ((strLength s) - 1);
                            addStr sf;
                            {properties = [:], params = array []}::als;
                        else
                            addStr s;
                            als;
                        fi 
                done [{properties = [:], params = array []}] argv;
                
            nargs = (reverse . filter ((not) . empty? . (.params))) nargs;

            nargs = nargs 
              |> map do {properties, params}:
                    r = fold do rs p:
                        if p == "-x" then
                            rs with {ex = true}
                        elif rs.ex then
                            rs with {ex = false,
                                     excludes = p :: rs.excludes};
                        else
                            rs with {names = p :: rs.names};
                        fi
                        done {ex = false, names = [], excludes = []}
                        params;
                    {properties,
                     names = r.names,
                     excludes = r.excludes}
                 done;
            
            //println nargs;
            //for (keys targets) println;
            try 
               for nargs do ps:

                    ns = (reverse . list) ps.names;
                    var props = [];
                    n = if (head ns) == "-x" then
                            if not empty? (tail ns) then
                                x = head (tail ns);
                                props := [ExcludeByName x];
                                x;
                            else
                                ""
                            fi
                        else
                            (head ns)
                        fi;
                    if n == "" then
                        () 
                    elif not n in config.targets then
                        println "\n--target: [\(n)] is no target!\n";
                        printSimilarTargets config.targets n;
                        throw new YbuilderAntException("\(n) is no target",());
                    else
                        t = config.targets[n];
                        println "--target: \(n)";
                        if not empty? ps.excludes then
                            println "  -x \(ps.excludes)";
                        fi;
                        runTarget t ([Args (tail ns), Properties ps.properties] 
                                     ++ (map ExcludeByName ps.excludes));
                    fi 
                done;
                "Build successful";
            catch YbuilderAntException ex:
                "Build Failed:\n\(ex#getMessage())\n\(ex#getCause())";
            yrt;
        fi;
    fi;


runCmds config args =
    (//register build targets if they are not yet registered
    if not "help" in config.targets then
        _ = registerBuildTargets config;
    fi;

    //check the args
    if empty? args then
        tn = case config.defaultTarget of
            None _: "help";
            Some t: t.name;
            esac;
        println (_evaluate config [tn])
    elif (head args) == "-c" then
        _repl (_evaluate config);
    else
        println (_evaluate config args)
    fi;

    //print time
    println "\ntotal build-time: \((millisSinceStart ()) / 1000) s";

    System#exit(0));

run config = 
    runCmds config (list _argv);

{
    createBuildConfig,
    registerBuildTargets,

    readProperties,
    assert,
    ybuilderVersion,

    createAntPath, 
    listPath,
    createAntClassLoader,
    listFiles,
    listDirs,
    targetToString,

    printSimilarTargets,
    
    target,
    doAfterTarget,
    runTarget,
    executeTarget,
    createProject,
    el,
    tel,
    antTaskWithElement,
    antTask,
    antInExcludeElements,
    antFilesetElement,
    antDirsetElement,
    antPathElements,
    //antPathById,
    file,
    millisSinceStart,

    buildDependenciesConfig,
    retrieveBuildDependencies, 
    runCmds,
    run,
}


