/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module ybuilder.core.run;

load ybuilder.core.build;

import java.lang:ClassLoader, Thread;
import org.apache.tools.ant:AntClassLoader;
import org.apache.tools.ant.types:Path;


repl eval = 
    (print "ybuilder> ";
    line = readln();
    if defined? line then
        ls = if strStarts? line "#" then 
                [line] 
             else 
                list (strSplit " " line) 
             fi;
        print (eval ls);
        repl eval;
    else
        println ""
    fi);



evalFun = (load yeti.lang.compiler.eval).evaluateYetiCode [] [Bind()];
evaluate config argv = 
    if empty? argv then
        "\n";
    elif (head argv) == "-yeti" then
        cl = 
            (load ybuilder.core.base;
             runTarget config.livecycleTargets.initialize [];
             pat = createAntPath (pathes.testRuntime config);
             new AntClassLoader(ClassLoader#getSystemClassLoader()#getParent(), 
                                pat#getProject(), pat, false));
        _ = (oldCl = Thread#currentThread()#getContextClassLoader();
             Thread#currentThread()#setContextClassLoader(cl);
             try
                m = cl#loadClass("yeti.lang.compiler.yeti")
                        #getMethod("main",array [classOf java.lang.String[]]);
                  m#invoke((),(array [(array (tail argv)) as ~String[] ]) 
                                as ~String[][]);
             finally
                Thread#currentThread()#setContextClassLoader(oldCl)
             yrt);
        
        "\n";
    else
        if strStarts? (head argv) "#" then
            code = strRight (strJoin " " argv) 1;
            (evalFun code).str;
        else
            nargs = 
                fold do als s:
                        addStr str =
                            (a = head als;
                            if strStarts? str "-"then
                                cut= strIndexOf str "=" 0;
                                if cut > 0 then
                                    value = strRight str (cut+1);
                                    key = strSlice str 1 cut;
                                    a.properties[key] := value;
                                else
                                    push a.params str
                                fi;
                            elif (strLength str) > 0 then
                                push a.params str
                            fi);
                        if strEnds? s "," then
                            sf = strLeft s ((strLength s) - 1);
                            addStr sf;
                            {properties = [:], params = array []}::als;
                        else
                            addStr s;
                            als;
                        fi 
                done [{properties = [:], params = array []}] argv;
                
            nargs = (reverse . filter ((not) . empty? . (.params))) nargs;

            nargs = nargs 
              |> map do {properties, params}:
                    r = fold do rs p:
                        if p == "-x" then
                            rs with {ex = true}
                        elif rs.ex then
                            rs with {ex = false,
                                     excludes = p :: rs.excludes};
                        else
                            rs with {names = p :: rs.names};
                        fi
                        done {ex = false, names = [], excludes = []}
                        params;
                    {properties,
                     names = r.names,
                     excludes = r.excludes}
                 done;
            
            //println nargs;
            //for (keys targets) println;
            try 
               for nargs do ps:

                    ns = list ps.names;
                    var props = [];
                    n = if (head ns) == "-x" then
                            if not empty? (tail ns) then
                                x = head (tail ns);
                                props := [ExcludeByName x];
                                x;
                            else
                                ""
                            fi
                        else
                            (head ns)
                        fi;
                    if n == "" then
                        () 
                    elif not n in config.targets then
                        println "\n--target: [\(n)] is no target!\n";
                        printSimilarTargets config.targets n;
                        throw new YbuilderAntException("\(n) is no target",());
                    else
                        t = config.targets[n];
                        println "--target: \(n)";
                        if not empty? ps.excludes then
                            println "  -x \(ps.excludes)";
                        fi;
                        runTarget t ([Args (tail ns), Properties ps.properties] 
                                     ++ (map ExcludeByName ps.excludes));
                    fi 
                done;
                "Build successful";
            catch YbuilderAntException ex:
                "Build Failed:\n\(ex#getMessage())\n\(ex#getCause())";
            yrt;
        fi;
    fi;

registerTargets config = 
    (_ = target config "buildlibs" "delete" 
            [Description 
            "deletes the buildlibs dir, which triggers next time a retrieve"]
        do p:
        antTask "delete" 
                    ["dir":buildDependenciesConfig.ybuilderLibsManaged] 
                    []
                    p;

        done;

    _ = target config "buildlibs" "retrieve" 
            [Description "retrieves the buildlibs"]
        do p:
            retrieveBuildDependencies ();
        done);

runCmds config args =
    (registerTargets config;
    if empty? args then
        tn = case config.defaultTarget of
            None _: "help";
            Some t: t.name;
            esac;
        println (evaluate config [tn])
    elif (head args) == "-c" then
        repl (evaluate config);
    else
        println (evaluate config args)
    fi;
    System#exit(0));

run config = 
    runCmds config (list _argv);
{
    runCmds,
    run
};



